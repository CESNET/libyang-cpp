{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "16ffdbc9_45073ec4",
        "filename": "include/libyang-cpp/DataNode.hpp",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-06-29T10:31:59Z",
      "side": 1,
      "message": "I (still) don\u0027t like this that much: there\u0027s this wording \"iter\" in something which is not an interator, and then there\u0027s a DataNodeCollection which assumes a particular iteration order, yet it doesn\u0027t say \"DFS\" in its name.\n\nAs you explained to me, the reason why we need this wrapper is because the STL expects to see functions begin() and end(). As I understand this, we cannot provide them at the DataNode level directly because there are more ways on how to iterate -- perhaps direct-children-only, perhaps a recursive DFS thing, perhaps a BFS one. Even if we disregard the BFS iterator, there are still two possible ways of iteration, which means that the C++ \"requires\" at least one wrapper, so that you can do:\n for (auto\u0026 child: dataNode) ...\n\nand:\n for (auto\u0026 node: dataNode.dfsChildren()) ...\n\nJust as well it would be OK to do it like this:\n for (auto\u0026 child: dataNode.children()) ...\n\nand:\n for (auto\u0026 node: dataNode.recursiveChildren()) ...\n\n...it\u0027s just a matter of where these begin() and end() are defined.\n\nSo, here\u0027s what I propose:\n\n1) you decide whether you want to support \"iteration directly over DataNode\u0027s direct children\", or whether you require a wrapper for both direct-children-only and another one for DFS iteration\n\n2) name all the types \"properly\", so that a collection which hard-wires DFS iteration has \"DFS\" in its name, and something which isn\u0027t an iterator doesn\u0027t call itself an iterator :)",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "806afcb4_2d9916c5",
        "filename": "include/libyang-cpp/DataNode.hpp",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-06-29T14:43:26Z",
      "side": 1,
      "message": "My idea was that I could make NodeCollection a template class and the template argument would be the type of the iterator. But right now, I only need support for dfs.\n\nSo, for now, I will just rename NodeCollection to NodeCollectionDfs and .iterateDepthFirst to .childrenDfs.\n\nIf I ever add the other types of iteration I can maybe change it to a template later.",
      "parentUuid": "16ffdbc9_45073ec4",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43bedc9b_db7eaddf",
        "filename": "include/libyang-cpp/DataNode.hpp",
        "patchSetId": 8
      },
      "lineNbr": 124,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-06-29T10:31:59Z",
      "side": 1,
      "message": "The code tracks validity state for both the original collection and all iterators; please explain why it is required. The way I read the code, only the collection ever gets invalidated, so it seems to me that you can just as well check the collection\u0027s validity instead of checking the \"cached\" copy of that in each iterator.\n\nAlso, right now there\u0027s nothing in the iterator which would pin the underlying collection to memory. That means that the collection might get out of scope, at which point there\u0027s nothing which will invalidate the iterators when a node gets unlinked. Please add some tests for this as well.",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "483c4ff3_bb9da89b",
        "filename": "include/libyang-cpp/DataNode.hpp",
        "patchSetId": 8
      },
      "lineNbr": 124,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-06-29T14:43:26Z",
      "side": 1,
      "message": "Hmm... maybe the code isn\u0027t completely clear and isn\u0027t really well written. To be honest, knowing what to invalidate and when isn\u0027t a simple task. As of now, calling unlink() invalidates all collections which in turn invalidates all iterators. But it seems that it invalidate ALL iterators, not just the ones from the specicif Collection.\n\nAlso, \"collection\" isn\u0027t the best name I suppose. It\u0027s more like a proxyobject which gives the .begin and .end iterators. I don\u0027t even know if it should be my responsibility to handle iterator invalidation\n\n    std::set\u003cint\u003e lol{1, 2};\n    auto it \u003d lol.begin();\n    lol \u003d {43,43};\n    std::cerr \u003c\u003c \"*it\" \u003c\u003c \" \u003d \" \u003c\u003c *it \u003c\u003c \"\\n\";\n\ncode like this gets asan errors and no exception are thrown.",
      "parentUuid": "43bedc9b_db7eaddf",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c426df1_085cf6bd",
        "filename": "src/DataNode.cpp",
        "patchSetId": 8
      },
      "lineNbr": 431,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-06-29T10:31:59Z",
      "side": 1,
      "message": "if this is correct (order of increment vs. dereferencing), can you please add a comment explaining why it\u0027s correct, and also a test which checks that both ++it and it++ do the right thing?",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d60b638_ffcb0ce4",
        "filename": "src/DataNode.cpp",
        "patchSetId": 8
      },
      "lineNbr": 431,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-06-29T14:43:26Z",
      "side": 1,
      "message": "The code was wrong, I was confused about returning postfix increment by reference. I added test",
      "parentUuid": "2c426df1_085cf6bd",
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02886ff4_45e49e03",
        "filename": "src/DataNode.cpp",
        "patchSetId": 8
      },
      "lineNbr": 451,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-06-29T10:31:59Z",
      "side": 1,
      "message": "Can you reuse operator*?\n return DataNodeProxy{**this};",
      "range": {
        "startLine": 446,
        "startChar": 0,
        "endLine": 451,
        "endChar": 54
      },
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18e38e60_0a7aa31b",
        "filename": "src/DataNode.cpp",
        "patchSetId": 8
      },
      "lineNbr": 451,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-06-29T14:43:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "02886ff4_45e49e03",
      "range": {
        "startLine": 446,
        "startChar": 0,
        "endLine": 451,
        "endChar": 54
      },
      "revId": "16e7442791a14e66ab4e660942b22bc032e9888e",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    }
  ]
}