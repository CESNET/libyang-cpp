{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f07cb0e6_1149be1d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-31T09:04:45Z",
      "side": 1,
      "message": "It looks like the custom deleter is untested. I would like to see a test which shows me when that deleter is needed and how it works.",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae2e1680_bb7ca137",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-31T11:24:46Z",
      "side": 1,
      "message": "I added a test for deleter and commit msg has an explanation why it\u0027s needed even though we\u0027re in C++. I\u0027m not completely sure it\u0027s really needed, so if you think otherwise, please tell me.",
      "parentUuid": "f07cb0e6_1149be1d",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ade672e1_66abda8a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-31T11:25:49Z",
      "side": 1,
      "message": "Actually, if you had a dynamically allocated char*, you could just save it in the lambda as a unique_ptr? So maybe you wouldn\u0027t need a deleter then.",
      "parentUuid": "ae2e1680_bb7ca137",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ae806e5_3b2fdce9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-31T11:30:26Z",
      "side": 1,
      "message": "No, actually the deleter is still \"needed\". in netconf-cli, the setup is a bit weird. My callback actually calls another callback, which gives the schema as a std::string. I need to copy this string, otherwise it gets released by std::string at the end of scope. And if I wanted to use the unique_ptr solution, I would have to save it somehow in the lambda... anyway, the deleter isn\u0027t 100% needed, but it makes things easier",
      "parentUuid": "ade672e1_66abda8a",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad48a38_44a92e73",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-31T11:38:02Z",
      "side": 1,
      "message": "If I understand your explanation correctly, the root cause is ModuleInfo::data being a non-owning thing (a raw C pointer with no well-defined semantics in this case). There are several options:\n\n1) Just use a std::string, nuke the deleter, and be done with it (well, the deleter should probably `delete reinterpret_cast\u003cModuleInfo*\u003e(userData)` and pass that to the C API I guess). Upside: trivial. Downside: extra memory allocation.\n\n2) Turn this into a string_view as a \"suggestion\" to the user that the memory is expected to \"somehow stay available\" until a deleter is invoked. Disadvantage: very un-C++ish because it doesn\u0027t follow the RAII.\n\n3) Come up with a custom data type with a virtual destructor and allow the user to override that if they need zero-copy.\n\nMy favorite is 1) of course because I just don\u0027t see this being in the hot path anywhere.",
      "parentUuid": "5ae806e5_3b2fdce9",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36f86941_85776470",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-31T12:24:44Z",
      "side": 1,
      "message": "I implemented the number 1 option. It does mean that the inner c-style callback needs to use strdup() because it cannot save the std::string.",
      "parentUuid": "5ad48a38_44a92e73",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d47cce3_d2f473c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-09-01T07:38:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "36f86941_85776470",
      "revId": "8458895e239855fa8c78373317b6484bb9436df0",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    }
  ]
}