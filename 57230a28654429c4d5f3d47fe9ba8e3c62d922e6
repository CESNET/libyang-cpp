{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c8148e2d_333e2a61",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-24T11:36:20Z",
      "side": 1,
      "message": "I guess I\u0027ll never learn what\u0027s the difference between all the access types.",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d136bba_6f339ea8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-24T11:40:04Z",
      "side": 1,
      "message": "I thought that making something protected just means, that derived classes can access it. I didn\u0027t know that making something protected in the derived class means that it\u0027s visible to the base class -.- This is one of the most confusing parts of C++ for me.",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27d2008d_67f2155f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-24T11:43:13Z",
      "side": 1,
      "message": "Oh well, I guess the constructor is still defined in the base class, so that\u0027s why the base class can see it? But then what would making the using statemenent protected do? lol",
      "parentUuid": "0d136bba_6f339ea8",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85e7d5f0_fadf33f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-24T11:46:03Z",
      "side": 1,
      "message": "I just wanted to make sure that \"the constructor\" of the derived class remains `protected`. The old version of the code used `private` everywhere, and I felt that a `protected` ctor in the base class and a `private` one in all derived classes would be confusing.\n\nI see that I forgot to change ActionRpcOutput and ActionRpc as well; I\u0027ll fix that.",
      "parentUuid": "27d2008d_67f2155f",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d030fecd_42b6e605",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-24T11:47:54Z",
      "side": 1,
      "message": "Tbh, everything about this is confusing to me, but it really comes down to me not being able to understand all of this :D I googled this multiple times and still can\u0027t get it...",
      "parentUuid": "85e7d5f0_fadf33f1",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3df0f1a_2828989b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-08-24T11:55:11Z",
      "side": 1,
      "message": "I think that `using Foo::Foo` just puts Foo::Foo into the \"current scope\", so it has an effect of saying that the constructor is declared and defined. Without `using SchemaNode::SchemaNode`, the derived class\u0027 default ctor would be invoked:\n \nIn member function ‘libyang::Leaf libyang::SchemaNode::asLeaf() const’:\nerror: too many initializers for ‘libyang::Leaf’\n  113 |     return Leaf{m_node, m_ctx};\n      |                              ^\n\nSo one has to \"bring in\" that ctor into the derived class, and I think that the access level of this statement works exactly the same as with any other statement -- when you declare something, it gets declared with the \"current access level\". It doesn\u0027t matter whether the base declared that thing as private or public or protected -- what matters is how the derived class declares that thing.",
      "parentUuid": "d030fecd_42b6e605",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0a1ec29_e4c3072a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-08-24T11:57:10Z",
      "side": 1,
      "message": "Thank you for the explanation. I think I found out why I\u0027m confused - the code doesn\u0027t work in clang and I\u0027m pretty sure clang is correct.",
      "parentUuid": "c3df0f1a_2828989b",
      "revId": "57230a28654429c4d5f3d47fe9ba8e3c62d922e6",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    }
  ]
}