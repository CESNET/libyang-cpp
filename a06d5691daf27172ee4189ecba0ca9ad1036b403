{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bbd29613_2f41df75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "The problem with YANG extensions is that they can do \"anything\", and that a lot of their functionality depends on custom libyang plugins. What is your end goal here, and how does the extension(s) that you want to support look like?",
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b749dc63_5502e6e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000096
      },
      "writtenOn": "2024-09-24T08:42:54Z",
      "side": 1,
      "message": "I don\u0027t mean that in a bad way, but I have to say it. I am still struggling with you CESNET git as your workflow is different to the rest of the world (and I am the only one who is willing to contribute and undergo such pain of usage this git system). It is such a pain to work with it and that is why I do things in one commit/one pull request, I have to have opened Gerrit documentation to be able to do anything there. It would be much more easier for everybody to use something a bit normal (like Github, Gitlab, Bitbucket) or something with standard workflow allowing multiple commits in one pull request, pull requests pointing to other pull request to be able to chain changes. If I do small commits/small pull requests without chaining them, it would take weeks to merge such pull request as this. To mention, I omitted part for plugin registration from this pull request in hope I would not take much time to implement it. But it is still blocking for the work. This is not man in the bad way, but I am (we are) still wondering why this system which neither powerful nor user friendly resulting in such pull requests as mine ...\n\nCan you tell me when should I rebased this pull request as you made several pull request extracting my changes? I hope I would be able to refactor it.",
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b9dcb9d_d80c2dff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-24T13:49:55Z",
      "side": 1,
      "message": "Thanks for your feedback, I\u0027m sorry to hear this. I hope that this link is useful for you:\n\n https://gerrit.cesnet.cz/Documentation/intro-gerrit-walkthrough-github.html \n\nWe care about git history and about atomic, small commits, and a PR-based workflow (like GitHub or GitLab ones) would make that almost impossible. Gerrit is used by a lot of projects including Android or Chrome, but I realize that the different workflow can be hard to get used to. Thanks for your patience and for taking the time to work with us.\n\nAs you noticed, I took the majority of this patch\u0027s content and split it into smaller chunks. It took me several hours, partly because I wasn\u0027t familiar with extensions (besides the rc:yang-data and the nmda:* ones which both serve a very different purpose), but also because your patch did not really explain why some changes were made. I had to go back to the spec and to speculate what you might need.\n\nI hope that the result is usable for you, and that the missing bits will be easy to implement as follow-up changes on top of that patch series. That\u0027s actually one of the strong points of Gerrit :), as long as you\u0027re willing to work with `git rebase -i`. That way, it\u0027s very easy to address reviewers\u0027 feedback and \"rewrite the (unmerged) git history\" to produce a clean sequence of commits.\n\nI encourage you to take a look at the patch series (basically, start at https://gerrit.cesnet.cz/c/CzechLight/libyang-cpp/+/7644/ and keep going through the \"relation chain\" in the upper right corner of the screen -- that\u0027s just the usual parent-of-a-commit relation that you know from regular git). I would appreciate your feedback on these changes.\n\n\u003e [...] allowing multiple commits in one pull request, pull requests pointing to other pull request to be able to chain changes. If I do small commits/small pull requests without chaining them, it would take weeks to merge such pull request as this.\n\nI don\u0027t understand this. Simply make your sequence of small commits as you would normally do them, on top of each other, with subsequent changes building on top of some features that were added in their parent/ancestor commits, and push them for review (all at once, or one at a time, whatever). Gerrit preserves this relation of parent-\u003echild commit chain 100%.\n\nE.g., if you have a series of (master) -\u003e A -\u003e B -\u003e C that you pushed for a review and you realize that you need to do a fixup on, say, B, use git\u0027s interactive rebase. This is actually one of the strong points of Gerrit where we don\u0027t have to revisit A and C if only B gets \"really changed\" (obviously C will become a \"different commit\" from git\u0027s point of view, but Gerrit will see that this new C is a new version of the old C via the Change-Id footer, and if it\u0027s indeed just a rebase of C on top of a \"new B\", it will be marked appropriately in the Gerrit UI).",
      "parentUuid": "b749dc63_5502e6e0",
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c54a2bd_e1ec5284",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 165,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "- in general, we don\u0027t necessarily follow an alphabetic order of methods, we would typically group them based on functionality.\n- please don\u0027t refactor (like this reordering of stuff) in a patch which also adds new functionality",
      "range": {
        "startLine": 165,
        "startChar": 4,
        "endLine": 165,
        "endChar": 48
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5edce408_d58d49a3",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "This is a per-plugin private object. In general, we don\u0027t want to make private data like this accessible from the C++ API. What do you need this for -- how will your code that\u0027s going to use this thing look like?",
      "range": {
        "startLine": 166,
        "startChar": 4,
        "endLine": 166,
        "endChar": 27
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca6ac7ec_1c1cc0c1",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1000096
      },
      "writtenOn": "2024-09-24T08:42:54Z",
      "side": 1,
      "message": "Whole purpose of this pull request is to be able to access extensions and parse them for needs of front-end. We will typically have extensions for GUI. \n\nAt this moment, we are at the testing stage, so we\u0027re exploring plugins, testing possibilities of extensions and its implementation into front-end through WebAssembly.\n\nWe have testing extension ui-map that has ui-map-latitude and ui-map-longitude that uses xpath to refer to fields inside of container to render such container as map. So it mean we need to parse ui-map extension (instance) and its nested extension (instances). And then, it is easier to access compiled part of the plugin that has already compiled structure, for example:\n\n```\nstruct re_ui_map {\n    const char *description;\n    const char *latitude;\n    const char *longitude;\n};\n```\n\nI am not sure if it is correct approach, but while we have compiled data, why not to access it. Otherwise we would need to perform similar steps again to construct such structure for our purpose.\n\nDo you think is it correct approach?",
      "parentUuid": "5edce408_d58d49a3",
      "range": {
        "startLine": 166,
        "startChar": 4,
        "endLine": 166,
        "endChar": 27
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8162c71_8ed396b1",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 166,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-24T13:49:55Z",
      "side": 1,
      "message": "What is being annotated, the YANG model itself, or the YANG data?\n\nThis is probably something much more complex than a set of physical (lat, lon) GPS coordinates of, say, physical HW that\u0027s deployed somewhere, right? If it was about that, then I would have expected either a standalone YANG-level list or a set of `augment`s to simply \"add more data\" an existing list -- in other words, the new data go into the YANG datastore content and not into the model.\n\nSo I guess it\u0027s about providing some hints to the UI from the YANG model (such as \"how to render the widget for controlling this setting\")? Are you maybe using something like:\n\n leaf some-settings {\n   type some-enumeration;\n   company:ui-widget-settings {\n     company:widget-type \"combobox\";\n     company:x-index \"100\";\n     company:y-index \"300\";\n   }\n }\n\n-\u003e How does the YANG model look like, and (if it\u0027s about annotating *data* instances) how does a typical instance of the data look like?",
      "parentUuid": "ca6ac7ec_1c1cc0c1",
      "range": {
        "startLine": 166,
        "startChar": 4,
        "endLine": 166,
        "endChar": 27
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a5e3ffb_353b0815",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 168,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "It took me some time to fully decipher this, and then I realized that extension instances can be extended, and so can the extension definitions. Yay, I228430278de1cfa7ac192574d25e50cf157c70a1.",
      "range": {
        "startLine": 168,
        "startChar": 4,
        "endLine": 168,
        "endChar": 62
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad02b56b_b6e81d87",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 169,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "I thought that the only way that you can actually obtain an ExtensionInstance involves going through an instance of the Module C++ class, but then I realized that this patch also adds support for fetching a list of instances from a schema node. Nice. I moved that part to Ic767dd4da4b194fe40fe2ede01e51fbc77bd3bb1 (and rewrote the tests).",
      "range": {
        "startLine": 169,
        "startChar": 4,
        "endLine": 169,
        "endChar": 26
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62053177_e34acc10",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 191,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "Is this needed? I wasn\u0027t able to come up with a situation where it\u0027s different from the argument name provided by the ExtensionInstance. Since there cannot be a (C++ level) object instance of the Extension class, I think it is not actually needed.",
      "range": {
        "startLine": 191,
        "startChar": 4,
        "endLine": 191,
        "endChar": 52
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d83b646a_de656208",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 191,
      "author": {
        "id": 1000096
      },
      "writtenOn": "2024-09-24T08:42:54Z",
      "side": 1,
      "message": "It is same as with extensionInstances. \n\n\u003e For the sake of completeness, I hope. While libyang C provides it, I wanted to implement complete API if needed by anyone.",
      "parentUuid": "62053177_e34acc10",
      "range": {
        "startLine": 191,
        "startChar": 4,
        "endLine": 191,
        "endChar": 52
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "332bd140_13c1b7c8",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 191,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-24T13:49:55Z",
      "side": 1,
      "message": "I think that the C API is driven by a slightly different design criteria, so I would prefer not to wrap redundant parts.",
      "parentUuid": "d83b646a_de656208",
      "range": {
        "startLine": 191,
        "startChar": 4,
        "endLine": 191,
        "endChar": 52
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5c79671_fd371364",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 192,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "Just wondering -- do you actually use this (and the ExtensionInstace::extensionInstaces()), or was that just for the sake of completeness?",
      "range": {
        "startLine": 192,
        "startChar": 4,
        "endLine": 192,
        "endChar": 62
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b96d6e4_bd0481f3",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 192,
      "author": {
        "id": 1000096
      },
      "writtenOn": "2024-09-24T08:42:54Z",
      "side": 1,
      "message": "For the sake of completeness, I hope. While libyang C provides it, I wanted to implement complete API if needed by anyone.",
      "parentUuid": "a5c79671_fd371364",
      "range": {
        "startLine": 192,
        "startChar": 4,
        "endLine": 192,
        "endChar": 62
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8eca72f4_09692db1",
        "filename": "include/libyang-cpp/Module.hpp",
        "patchSetId": 6
      },
      "lineNbr": 192,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-24T13:49:55Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "9b96d6e4_bd0481f3",
      "range": {
        "startLine": 192,
        "startChar": 4,
        "endLine": 192,
        "endChar": 62
      },
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "488c88d2_52019a12",
        "filename": "src/Module.cpp",
        "patchSetId": 6
      },
      "lineNbr": 398,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-09-23T18:41:31Z",
      "side": 1,
      "message": "This bugfix should go into a separate commit (without reordering the function definitions in the header file, and with a test), so that\u0027s I531fcd87da518985bf8f730675b3d20c197224db.",
      "revId": "a06d5691daf27172ee4189ecba0ca9ad1036b403",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68"
    }
  ]
}